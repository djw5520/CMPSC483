<!DOCTYPE html>
<meta charset="utf-8">
<style>
    svg {
        font: 10px sans-serif;
    }

    .background path {
        fill: none;
        stroke: #ddd;
        shape-rendering: crispEdges;
    }

    .foreground path {
        fill: none;
        stroke: steelblue;
    }

    .brush .extent {
        fill-opacity: .3;
        stroke: #fff;
        shape-rendering: crispEdges;
    }

    .axis line,
    .axis path {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .axis text {
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
        cursor: move;
    }
</style>
<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="./parcoords/d3_v4.parcoords.js"></script>
<script>
    // linear color scale
    var blue_to_brown = d3.scaleLinear()
        .domain([9, 50])
        .range(["steelblue", "brown"])
        .interpolate(d3.interpolateLab);

    // interact with this variable from a javascript console
    var pc1;

    // load csv file and create the chart
    d3.csv('./cars.csv', function(data) {
        pc1 = d3.parcoords()("#example1")
            .data(data)
            .hideAxis(["name"])
            .composite("darken")
            .color(function(d) { return blue_to_brown(d['economy (mpg)']); })  // quantitative color scale
            .alpha(0.35)
            .render()
            .brushMode("1D-axes")  // enable brushing
            .interactive();  // command line mode

        var explore_count = 0;
        var exploring = {};
        var explore_start = false;
        pc1.svg
            .selectAll(".dimension")
            .style("cursor", "pointer")
            .on("click", function(d) {
                exploring[d] = d in exploring ? false : true;
                event.preventDefault();
                if (exploring[d]) d3.timer(explore(d,explore_count));
            });

        function explore(dimension,count) {
            if (!explore_start) {
                explore_start = true;
                d3.timer(pc1.brush);
            }
            var speed = (Math.round(Math.random()) ? 1 : -1) * (Math.random()+0.5);
            return function(t) {
                if (!exploring[dimension]) return true;
                var domain = pc1.yscale[dimension].domain();
                var width = (domain[1] - domain[0])/4;

                var center = width*1.5*(1+Math.sin(speed*t/1200)) + domain[0];

                pc1.yscale[dimension].brush.extent([
                    d3.max([center-width*0.01, domain[0]-width/400]),
                    d3.min([center+width*1.01, domain[1]+width/100])
                ])(pc1.g()
                    .filter(function(d) {
                        return d == dimension;
                    })
                );
            };
        }

    });
//    let margin = {top: 30, right: 10, bottom: 10, left: 10},
//        width = 960 - margin.left - margin.right,
//        height = 500 - margin.top - margin.bottom;
//
//    let x = d3.scalePoint().range([0, width]).padding(1),
//        range = [-8, 8];
//        y = {},
//        dragging = {};
//
//    let line = d3.line(),
//        axis = d3.axisLeft(x), //Argument for axisLeft? Compare to code on original plot
//        background,
//        foreground;
//
//    let svg = d3.select("body").append("svg")
//        .attr("width", width + margin.left + margin.right)
//        .attr("height", height + margin.top + margin.bottom)
//        .append("g")
//        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
//    d3.csv("cars.csv", function (error, cars) {
//
//        // Extract the list of dimensions and create a scale for each.
//        x.domain(dimensions = d3.keys(cars[0]).filter(function (d) {
//            return d !== "name" && (y[d] = d3.scaleLinear()
//                .domain(d3.extent(cars, function (p) {
//                    return +p[d];
//                }))
//                .range([height, 0]));
//        }));
//
//        // Add grey background lines for context.
//        background = svg.append("g")
//            .attr("class", "background")
//            .selectAll("path")
//            .data(cars)
//            .enter().append("path")
//            .attr("d", path);
//
//        // Add blue foreground lines for focus.
//        foreground = svg.append("g")
//            .attr("class", "foreground")
//            .selectAll("path")
//            .data(cars)
//            .enter().append("path")
//            .attr("d", path);
//
//        // Add a group element for each dimension.
//        let g = svg.selectAll(".dimension")
//            .data(dimensions)
//            .enter().append("g")
//            .attr("class", "dimension")
//            .attr("transform", function (d) {
//                return "translate(" + x(d) + ")";
//            })
//            .call(d3.drag()
//                .subject(function (d) {
//                    return {x: x(d)};
//                })
//                .on("start", function (d) {
//                    dragging[d] = x(d);
//                    background.attr("visibility", "hidden");
//                })
//                .on("drag", function (d) {
//                    dragging[d] = Math.min(width, Math.max(0, d3.event.x));
//                    foreground.attr("d", path);
//                    dimensions.sort(function (a, b) {
//                        return position(a) - position(b);
//                    });
//                    x.domain(dimensions);
//                    g.attr("transform", function (d) {
//                        return "translate(" + position(d) + ")";
//                    })
//                })
//                .on("end", function (d) {
//                    delete dragging[d];
//                    transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
//                    transition(foreground).attr("d", path);
//                    background
//                        .attr("d", path)
//                        .transition()
//                        .delay(500)
//                        .duration(0)
//                        .attr("visibility", null);
//                }));
//
//        // Add an axis and title.
//        g.append("g")
//            .attr("class", "axis")
//            .each(function (d) {
//                d3.select(this).call(axis.scale(y[d]));
//            })
//            .append("text")
//            .style("text-anchor", "middle")
//            .attr("y", -9)
//            .text(function (d) {
//                return d;
//            });
//
//        // Add and store a brush for each axis.
//        g.append("g")
//            .attr("class", "brush")
//            .each(function (d) {
//                d3.select(this).call(y[d].brush = d3.brushY().extent([[range[0], 0], [range[1], height]]).on("start", brushstart).on("brush", brush));
//            })
//            .selectAll("rect")
//            .attr("x", -8)
//            .attr("width", 16);
//    });
//
//    function position(d) {
//        let v = dragging[d];
//        return v == null ? x(d) : v;
//    }
//
//    function transition(g) {
//        return g.transition().duration(500);
//    }
//
//    // Returns the path for a given data point.
//    function path(d) {
//        return line(dimensions.map(function (p) {
//            return [position(p), y[p](d[p])];
//        }));
//    }
//
//    function brushstart() {
//        d3.event.sourceEvent.stopPropagation();
//    }
//
//    // Handles a brush event, toggling the display of foreground lines.
//    function brush() {
//        //return !y[p].brush.empty was the original return value.
//
//        let actives = dimensions.filter(function (d) {
//                return y[d].brush.selection !== undefined;
//            });
//        let selection = actives.map(function (d) {
//                return y[d].brush.selection;
//            });
//            console.log(selection);
//
//        foreground.style("display", function (d) {
//            return actives.every(function (p, i) {
//                return selection[i][0] <= d[p] && d[p] <= selection[i][1];
//            }) ? null : "none";
//        });
//    }
</script>



<!--Replace d3.svg.brush() with d3.brushX().-->
<!--Rename brushstart event to start, brushend to end.-->
<!--Don't pass scale to .x(xScale), this method is now missing. Pass brush borders as .extent([[xScale.range()[0], 0], [xScale.range()[1], brushHeight]]).-->
<!--In event handler you can get selection as d3.event.selection, for getting selected values use  d3.event.selection.map(xScale.invert).-->
<!--To setup selection do .move(brushContainer, selectedDomain.map(xScale)). To clear selection do .move(brushContainer, null). Note that this will fire event handlers.-->
<!--.empty() method is now missing, use d3.event.selection === null.-->
<!--Update your CSS, .extent is now .selection, .resize is .handle and became a rect instead of g containing rect.-->